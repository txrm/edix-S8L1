# coding: utf-8

"""
    AEMET OpenData

    AEMET OpenData es una API REST desarrollado por AEMET que permite la difusión y la reutilización de la información meteorológica y climatológica de la Agencia, en el sentido indicado en la Ley 18/2015, de 9 de julio, por la que se modifica la Ley 37/2007, de 16 de noviembre, sobre reutilización de la información del sector público. (IMPORTANTE: Para poder realizar peticiones, es necesario introducir en API Key haciendo clic en el círculo rojo de recurso REST).  # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ObservacionConvencionalApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def datos_de_observacin__tiempo_actual_(self, **kwargs):  # noqa: E501
        """Datos de observación. Tiempo actual.  # noqa: E501

        Datos de observación horarios de las últimas 24 horas todas las estaciones meteorológicas de las que se han recibido datos en ese período. Frecuencia de actualización: continuamente.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datos_de_observacin__tiempo_actual_(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.datos_de_observacin__tiempo_actual__with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.datos_de_observacin__tiempo_actual__with_http_info(**kwargs)  # noqa: E501
            return data

    def datos_de_observacin__tiempo_actual__with_http_info(self, **kwargs):  # noqa: E501
        """Datos de observación. Tiempo actual.  # noqa: E501

        Datos de observación horarios de las últimas 24 horas todas las estaciones meteorológicas de las que se han recibido datos en ese período. Frecuencia de actualización: continuamente.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datos_de_observacin__tiempo_actual__with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datos_de_observacin__tiempo_actual_" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/observacion/convencional/todas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def datos_de_observacin__tiempo_actual_1(self, idema, **kwargs):  # noqa: E501
        """Datos de observación. Tiempo actual.  # noqa: E501

        Datos de observación horarios de las últimas 24 horas de la estación meterológica que se pasa como parámetro (idema). Frecuencia de actualización: continuamente.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datos_de_observacin__tiempo_actual_1(idema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str idema: Índicativo climatológico de la EMA (required)
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.datos_de_observacin__tiempo_actual_1_with_http_info(idema, **kwargs)  # noqa: E501
        else:
            (data) = self.datos_de_observacin__tiempo_actual_1_with_http_info(idema, **kwargs)  # noqa: E501
            return data

    def datos_de_observacin__tiempo_actual_1_with_http_info(self, idema, **kwargs):  # noqa: E501
        """Datos de observación. Tiempo actual.  # noqa: E501

        Datos de observación horarios de las últimas 24 horas de la estación meterológica que se pasa como parámetro (idema). Frecuencia de actualización: continuamente.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datos_de_observacin__tiempo_actual_1_with_http_info(idema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str idema: Índicativo climatológico de la EMA (required)
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['idema']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datos_de_observacin__tiempo_actual_1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'idema' is set
        if ('idema' not in params or
                params['idema'] is None):
            raise ValueError("Missing the required parameter `idema` when calling `datos_de_observacin__tiempo_actual_1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'idema' in params:
            path_params['idema'] = params['idema']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/observacion/convencional/datos/estacion/{idema}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mensajes_de_observacin__ltimo_elaborado_(self, tipomensaje, **kwargs):  # noqa: E501
        """Mensajes de observación. Último elaborado.  # noqa: E501

        Últimos mensajes de observación. Para los SYNOP y TEMP devuelve los mensajes de las últimas 24 horas y para los CLIMAT de los 40 últimos dias. Se pasa como parámetro el tipo de mensaje que se desea (tipomensaje). El resultado de la petición es un fichero en formato tar.gz, que contiene los boletines en formato json y bufr.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mensajes_de_observacin__ltimo_elaborado_(tipomensaje, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tipomensaje:  | Código | Tipo de Mensaje | |----------|----------| | climat  | CLIMAT   | | synop  | SYNOP   | | temp  | TEMP   (required)
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mensajes_de_observacin__ltimo_elaborado__with_http_info(tipomensaje, **kwargs)  # noqa: E501
        else:
            (data) = self.mensajes_de_observacin__ltimo_elaborado__with_http_info(tipomensaje, **kwargs)  # noqa: E501
            return data

    def mensajes_de_observacin__ltimo_elaborado__with_http_info(self, tipomensaje, **kwargs):  # noqa: E501
        """Mensajes de observación. Último elaborado.  # noqa: E501

        Últimos mensajes de observación. Para los SYNOP y TEMP devuelve los mensajes de las últimas 24 horas y para los CLIMAT de los 40 últimos dias. Se pasa como parámetro el tipo de mensaje que se desea (tipomensaje). El resultado de la petición es un fichero en formato tar.gz, que contiene los boletines en formato json y bufr.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mensajes_de_observacin__ltimo_elaborado__with_http_info(tipomensaje, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tipomensaje:  | Código | Tipo de Mensaje | |----------|----------| | climat  | CLIMAT   | | synop  | SYNOP   | | temp  | TEMP   (required)
        :return: Model200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tipomensaje']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mensajes_de_observacin__ltimo_elaborado_" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tipomensaje' is set
        if ('tipomensaje' not in params or
                params['tipomensaje'] is None):
            raise ValueError("Missing the required parameter `tipomensaje` when calling `mensajes_de_observacin__ltimo_elaborado_`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tipomensaje' in params:
            path_params['tipomensaje'] = params['tipomensaje']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/observacion/convencional/mensajes/tipomensaje/{tipomensaje}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
